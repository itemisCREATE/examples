/** Generated by itemis CREATE code generator. */

#ifndef SC_TIMER_SERVICE_H_
#define SC_TIMER_SERVICE_H_

#include "sc_types.h"

#ifdef __cplusplus
extern "C" {
#endif

/*! Interface definition of a timer service for itemis CREATE state machines. */

typedef void (*sc_raise_time_event_fp)(void *handle, sc_eventid evid);
typedef void (*sc_run_cycle_fp)(void *handle);

typedef struct
{
    sc_raise_time_event_fp raise_event;
    sc_eventid pt_evid;
    sc_boolean periodic;
} time_based;

typedef struct
{
    sc_time time_ms;
    sc_run_cycle_fp run_cycle;
    time_based time_event;
    void *statemachine;
} non_empty;

typedef enum { EMPTY_TASK, TIME_EVENT_TASK, RUNCYCLE_TASK } task_type;

typedef struct
{
    task_type type;
    non_empty get;
} task_data;

/* A timer task. */
typedef struct
{
    task_data data;
    sc_time elapsed_time_ms;
    sc_integer next_task_idx;
} sc_timer_t;

typedef struct
{
    void *statemachine;
    sc_eventid pt_evid;
} match_time_event;

typedef struct
{
    void *statemachine;
} match_run_cycle_of;

typedef union {
    match_time_event match_time_event_;
    match_run_cycle_of match_run_cycle_of_;
} timer_task_matcher_data;

typedef struct
{
    timer_task_matcher_data data;
    sc_boolean is_match_time_event;
} timer_task_matcher;

typedef struct
{
    sc_integer length;
    sc_timer_t *tasks;
    sc_integer next_active_task;
    sc_integer next_free_task;
    sc_raise_time_event_fp raise_event;
} sc_timer_service_t;

void reset_task_data(task_data *data);

void execute(task_data *data);

void update_elapsed_time_ms(sc_timer_t *task, sc_time elapsed_time_ms_);

sc_boolean is_periodic(sc_timer_t *task);

sc_boolean is_runcycle_event(sc_timer_t *task);

void reset_timer_task(sc_timer_t *task);

sc_boolean less_than(sc_timer_t *task, sc_timer_t *other);

sc_boolean time_event_matcher(match_time_event *matcher, const sc_timer_t *other);

sc_boolean run_cycle_matcher(match_run_cycle_of *matcher, const sc_timer_t *other);

void set_generic_timer(sc_timer_service_t *timer_service, const task_data data);

void unset_generic_timer(sc_timer_service_t *timer_service, timer_task_matcher *matcher);

void sc_timer_service_init(sc_timer_service_t *timer_service,
                           sc_timer_t *tasks_,
                           sc_integer length_,
                           sc_raise_time_event_fp raise_event);

void sc_timer_set(sc_timer_service_t *timer_service,
                  void *handle,
                  const sc_eventid evid,
                  const sc_time time_ms,
                  const sc_boolean periodic);

void sc_timer_set_for_raise_event(sc_timer_service_t *timer_service,
                              sc_raise_time_event_fp raise_event,
                              void *statemachine,
                              const sc_eventid evid,
                              const sc_time time_ms,
                              const sc_boolean periodic);

void sc_timer_unset(sc_timer_service_t *timer_service, sc_eventid evid);

void sc_timer_unset_for_machine(sc_timer_service_t *timer_service,
                                sc_eventid evid,
                                void *statemachine);

void set_runcycle_timer_for(sc_timer_service_t *timer_service,
                            sc_run_cycle_fp run_cycle,
                            void *statemachine,
                            sc_time cycle_period);

void unset_runcycle_timer(sc_timer_service_t *timer_service, void *statemachine);

void sc_timer_service_proceed(sc_timer_service_t *timer_service, sc_time elapsed_ms);

void cancel(sc_timer_service_t *timer_service);

sc_time time_till_next_task(sc_timer_service_t *timer_service);

#ifdef __cplusplus
}
#endif

#endif /* SC_TIMER_SERVICE_H_ */

