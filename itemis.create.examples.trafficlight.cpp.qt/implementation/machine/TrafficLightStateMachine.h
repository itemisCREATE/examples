/** Generated by itemis CREATE code generator. */

#ifndef TRAFFICLIGHTSTATEMACHINE_H_
#define TRAFFICLIGHTSTATEMACHINE_H_

/*!
Forward declaration for the TrafficLightStateMachine state machine.
*/
class TrafficLightStateMachine;


#include <deque>
#include "sc_types.h"
#include "sc_rxcpp.h"
#include "sc_statemachine.h"
#include "sc_eventdriven.h"
#include "sc_timer.h"
#include <memory>
#include <string.h>
#include <QObject>

/*! \file
Header of the state machine 'TrafficLightStateMachine'.
*/


class TrafficLightStateMachine : public QObject, public sc::timer::TimedInterface, public std::enable_shared_from_this<sc::timer::TimedInterface>, public sc::EventDrivenInterface
{
	Q_OBJECT
	
	public:
		explicit TrafficLightStateMachine(QObject *parent) noexcept;
		
		virtual ~TrafficLightStateMachine();
		
		
		
		/*! Enumeration of all states. */
		enum class State
		{
			NO_STATE,
			trafficlight_operating,
			trafficlight_operating_r_prepare,
			trafficlight_operating_r_prepare_switch_to_go,
			trafficlight_operating_r_prepare_switch_to_stop,
			trafficlight_operating_r_stop,
			trafficlight_operating_r_go,
			trafficlight_standby,
			trafficlight_standby_blink_on,
			trafficlight_standby_blink_off
		};
		
		/*! The number of states. */
		static constexpr const sc::integer numStates {9};
		static constexpr const sc::integer scvi_trafficlight_operating {0};
		static constexpr const sc::integer scvi_trafficlight_operating_r_prepare {0};
		static constexpr const sc::integer scvi_trafficlight_operating_r_prepare_switch_to_go {0};
		static constexpr const sc::integer scvi_trafficlight_operating_r_prepare_switch_to_stop {0};
		static constexpr const sc::integer scvi_trafficlight_operating_r_stop {0};
		static constexpr const sc::integer scvi_trafficlight_operating_r_go {0};
		static constexpr const sc::integer scvi_trafficlight_standby {0};
		static constexpr const sc::integer scvi_trafficlight_standby_blink_on {0};
		static constexpr const sc::integer scvi_trafficlight_standby_blink_off {0};
		
		/*! Enumeration of all events which are consumed. */
		enum class Event
		{
			NO_EVENT,
			standby,
			operate,
			_te0_trafficlight_operating_r_prepare_switch_to_go_,
			_te1_trafficlight_operating_r_prepare_switch_to_stop_,
			_te2_trafficlight_operating_r_stop_,
			_te3_trafficlight_operating_r_go_,
			_te4_trafficlight_standby_blink_on_,
			_te5_trafficlight_standby_blink_off_
		};
		
		class EventInstance
		{
			public:
				explicit  EventInstance(Event id) noexcept : eventId(id){}
				virtual ~EventInstance() = default;
				const Event eventId;
		};
		/*! Get observable for event 'redOn' of default interface scope. */
		sc::rx::Observable<void>& getRedOn() noexcept;
		/*! Get observable for event 'redOff' of default interface scope. */
		sc::rx::Observable<void>& getRedOff() noexcept;
		/*! Get observable for event 'yellowOn' of default interface scope. */
		sc::rx::Observable<void>& getYellowOn() noexcept;
		/*! Get observable for event 'yellowOff' of default interface scope. */
		sc::rx::Observable<void>& getYellowOff() noexcept;
		/*! Get observable for event 'greenOn' of default interface scope. */
		sc::rx::Observable<void>& getGreenOn() noexcept;
		/*! Get observable for event 'greenOff' of default interface scope. */
		sc::rx::Observable<void>& getGreenOff() noexcept;
		
		
		
		/*! Can be used by the client code to trigger a run to completion step without raising an event. */
		void triggerWithoutEvent() override;
		/*
		 * Functions inherited from StatemachineInterface
		 */
		 void enter() override;
		
		 void exit() override;
		
		/*!
		 * Checks if the state machine is active (until 2.4.1 this method was used for states).
		 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		 */
		 bool isActive() const noexcept override;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		 bool isFinal() const noexcept override;
		
		/*! 
		 * Checks if member of the state machine must be set. For example an operation callback.
		 */
		bool check() const noexcept;
		
		/*
		 * Functions inherited from TimedStatemachineInterface
		 */
		void setTimerService(std::shared_ptr<sc::timer::TimerServiceInterface> timerService_) noexcept override;
		
		std::shared_ptr<sc::timer::TimerServiceInterface> getTimerService() noexcept override;
		
		void raiseTimeEvent(sc::eventid event) override;
		
		sc::integer getNumberOfParallelTimeEvents() noexcept override;
		
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		bool isStateActive(State state) const noexcept;
		
		//! number of time events used by the state machine.
		static const sc::integer timeEventsCount {6};
		
		//! number of time events that can be active at once.
		static const sc::integer parallelTimeEventsCount {1};
		
		
	public slots:
		/*! Slot for the in event 'standby' that is defined in the default interface scope. */
		void standby();
		
		/*! Slot for the in event 'operate' that is defined in the default interface scope. */
		void operate();
		
		
	signals:
		/*! Signal representing the out event 'redOn' that is defined in the default interface scope. */
		void redOn();
		
		/*! Signal representing the out event 'redOff' that is defined in the default interface scope. */
		void redOff();
		
		/*! Signal representing the out event 'yellowOn' that is defined in the default interface scope. */
		void yellowOn();
		
		/*! Signal representing the out event 'yellowOff' that is defined in the default interface scope. */
		void yellowOff();
		
		/*! Signal representing the out event 'greenOn' that is defined in the default interface scope. */
		void greenOn();
		
		/*! Signal representing the out event 'greenOff' that is defined in the default interface scope. */
		void greenOff();
		
	
	protected:
		
		
		std::deque<std::unique_ptr<EventInstance>> incomingEventQueue;
		
		std::unique_ptr<EventInstance> getNextEvent() noexcept;
		
		bool dispatchEvent(std::unique_ptr<EventInstance> event) noexcept;
		
		
		
	private:
		TrafficLightStateMachine(const TrafficLightStateMachine &rhs);
		TrafficLightStateMachine& operator=(const TrafficLightStateMachine&);
		
		
		
		
		
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc::ushort maxOrthogonalStates {1};
		
		std::shared_ptr<sc::timer::TimerServiceInterface> timerService;
		bool timeEvents[timeEventsCount];
		
		
		State stateConfVector[maxOrthogonalStates];
		
		
		
		
		bool isExecuting {false};
		
		
		
		// prototypes of all internal functions
		
		sc::integer react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_r_prepare_react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_r_prepare_switch_to_go_react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_r_prepare_switch_to_stop_react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_r_stop_react(const sc::integer transitioned_before);
		sc::integer trafficlight_operating_r_go_react(const sc::integer transitioned_before);
		sc::integer trafficlight_standby_react(const sc::integer transitioned_before);
		sc::integer trafficlight_standby_blink_on_react(const sc::integer transitioned_before);
		sc::integer trafficlight_standby_blink_off_react(const sc::integer transitioned_before);
		void clearInEvents() noexcept;
		void microStep();
		void runCycle();
		
		
		
		/*! Observable for event 'redOn' of default interface scope. */
		sc::rx::Observable<void> redOn_observable = sc::rx::Observable<void>{};
		
		/*! Observable for event 'redOff' of default interface scope. */
		sc::rx::Observable<void> redOff_observable = sc::rx::Observable<void>{};
		
		/*! Observable for event 'yellowOn' of default interface scope. */
		sc::rx::Observable<void> yellowOn_observable = sc::rx::Observable<void>{};
		
		/*! Observable for event 'yellowOff' of default interface scope. */
		sc::rx::Observable<void> yellowOff_observable = sc::rx::Observable<void>{};
		
		/*! Observable for event 'greenOn' of default interface scope. */
		sc::rx::Observable<void> greenOn_observable = sc::rx::Observable<void>{};
		
		/*! Observable for event 'greenOff' of default interface scope. */
		sc::rx::Observable<void> greenOff_observable = sc::rx::Observable<void>{};
		
		/*! Indicates event 'standby' of default interface scope is active. */
		bool standby_raised {false};
		
		/*! Indicates event 'operate' of default interface scope is active. */
		bool operate_raised {false};
		
		
		
};




#endif /* TRAFFICLIGHTSTATEMACHINE_H_ */
