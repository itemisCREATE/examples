/** Generated by itemis CREATE code generator. */

#ifndef SC_QT_TIMERSERVICE_H_
#define SC_QT_TIMERSERVICE_H_


#include <QObject>
#include <QTimer>
#include <QMap>
#include <QPair>

#include "sc_timer.h"


namespace sc
{

namespace qt
{

    class SCTimer : public QTimer
    {
        Q_OBJECT

    public:
        explicit SCTimer(QObject * parent, std::weak_ptr<sc::timer::TimedInterface> machine, const sc::eventid id);
        
        virtual ~SCTimer();

    signals:
        void fireTimeEvent(std::shared_ptr<sc::timer::TimedInterface> machine, sc::eventid event);

    public slots:
        void triggerTimeEvent();

    protected:
        std::weak_ptr<sc::timer::TimedInterface> machine;
        sc::eventid eventId;
    };



    class SCTimerService : public QObject, public sc::timer::TimerServiceInterface
    {
        Q_OBJECT

    public:
        explicit SCTimerService(QObject *parent);
        
        virtual ~SCTimerService();

        virtual void setTimer(std::shared_ptr<sc::timer::TimedInterface> statemachine, sc::eventid event, sc::time time_ms, bool isPeriodic);
        virtual void unsetTimer(std::shared_ptr<sc::timer::TimedInterface> statemachine, sc::eventid event);
        virtual void cancel();

    signals:

    public slots:
        void raiseTimeEvent(std::shared_ptr<sc::timer::TimedInterface> machine, sc::eventid event);

    protected:
        QMap<std::shared_ptr<sc::timer::TimedInterface>,QMap<sc::eventid, std::shared_ptr<SCTimer>>*> machineTimerMapMap;
        std::shared_ptr<SCTimer> getTimer(std::shared_ptr<sc::timer::TimedInterface> machine, sc::eventid event);

    };

} // namespace qt

} // namespace sc

#endif // SC_QT_TIMERSERVICE_H_


