/** Generated by itemis CREATE code generator. */

#ifndef SC_RXCPP_H_
#define SC_RXCPP_H_

#include "sc_types.h"
#include <memory>
#include <vector>
#include <algorithm>
#include <functional>

namespace sc {
namespace rx {

template<class T> class Observer;
template<> class Observer<void> ;
template<class T> class subscription;
template<class T> class Observable;
template<> class Observable<void> ;

template<class T>
class Observer {
public:
	virtual ~Observer() {
	}
	virtual void next(T value) = 0;
};

template<>
class Observer<void> {
public:
	virtual ~Observer() {
	}
	virtual void next() = 0;
};

template<class T>
class SingleSubscriptionObserver: public Observer<T> {
public:
	SingleSubscriptionObserver() noexcept {
	}

	bool subscribe(sc::rx::Observable<T> &o) noexcept {
		return o.subscribe(subscription);
	}

	bool unsubscribe(sc::rx::Observable<T> &o) noexcept {
		return o.unsubscribe(subscription);
	}

	void setSubscription(sc::rx::subscription<T> &s) noexcept {
			subscription = s;
	}
	
	virtual ~SingleSubscriptionObserver() = default;

protected:
	sc::rx::subscription<T> subscription;
};

template<class T>
class subscription {
protected:
	std::shared_ptr<std::reference_wrapper<Observer<T> > > observer;
public:	
	subscription()  noexcept : observer(nullptr) {
	}

	subscription(Observer<T> &o) noexcept :
				observer(std::make_shared<std::reference_wrapper<Observer<T> > >(o)) {
	}

	bool operator==(const subscription &other) const  noexcept{
		return observer == other.observer;
	}
	
	bool operator!=(const subscription &other) const  noexcept {
		return !(*this == other);
	}
	
	Observer<T> &operator*() const  noexcept {
		return observer->get();
	}
	
	Observer<T> *operator->() const  noexcept {
		return &(observer->get());
	}
	
	operator bool() const  noexcept {
		return observer.get() != nullptr;
	}
	
	virtual ~subscription() = default;
};

template<class T> class ObservableBase {
public:
	ObservableBase() noexcept
	{
	}

	bool subscribe(subscription<T> &s) noexcept {
		if (s && std::find(this->subscriptions.begin(), this->subscriptions.end(), s) == this->subscriptions.end()) {
			this->subscriptions.push_back(s);
			return true;
		}
		return false;
	}

	bool unsubscribe(subscription<T> &s) noexcept {
		if (!this->subscriptions.empty()) {
			auto old_end = this->subscriptions.end();
			this->subscriptions.erase(std::remove(this->subscriptions.begin(), this->subscriptions.end(), s), this->subscriptions.end());
			if(std::distance(old_end, this->subscriptions.end()) != 0){
				return true;
			}
			return false;
		}
		return false;
	}
	
	virtual ~ObservableBase() = default;

protected:
	std::vector<subscription<T>> subscriptions;

};

template<class T>
class Observable: public ObservableBase<T> {

public:

	void next(T value) {
		for (auto sub = this->subscriptions.begin() ; sub != this->subscriptions.end(); ++sub){
			if (*sub) {
				(*sub)->next(value);
			}
		}
	}
	
	virtual ~Observable() = default;

};

template<>
class Observable<void> : public ObservableBase<void> {

public:
	void next() {
		for (auto sub = this->subscriptions.begin() ; sub != this->subscriptions.end(); ++sub){
			if (*sub) {
				(*sub)->next();
			}
		}
	}
	
	virtual ~Observable() = default;

};

} /* namespace sc::rx */
} /* namespace sc */

#endif /* SC_RXCPP_H_ */
