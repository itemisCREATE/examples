/** Generated by itemis CREATE code generator. */
package com.yakindu.core;

import java.math.BigInteger;
import java.util.PriorityQueue;
import java.util.Queue;

public class VirtualTimer implements ITimerService {
	
	private BigInteger stopTime = BigInteger.ZERO;
	protected BigInteger currentTime = BigInteger.ZERO;
	protected long cyclePeriod = 0;
	protected BigInteger scheduleCount = BigInteger.ZERO;

	private Queue<VirtualTimeTask> tasks;

	public abstract static class VirtualTimeTask implements Runnable, Comparable<VirtualTimeTask> {

		BigInteger nextExecutionTime = BigInteger.ZERO;
		long interval = 0;
		long period = -1;
		BigInteger scheduleOrder = BigInteger.ZERO;
		boolean isCanceled = false;

		public int compareTo(VirtualTimeTask o) {
			
			BigInteger diff = BigInteger.ZERO;
			
			if (!nextExecutionTime.equals(o.nextExecutionTime)) {
				diff = nextExecutionTime.subtract(o.nextExecutionTime);
			} else if (o instanceof CycleTimeEventTask && !(this instanceof CycleTimeEventTask)) {
				return -1;
			} else if (!(o instanceof CycleTimeEventTask) && this instanceof CycleTimeEventTask) {
				return 1;
			} else {
				diff = scheduleOrder.subtract(o.scheduleOrder);
			}		
			return diff.compareTo(BigInteger.ZERO);
		}

		public boolean isCanceled() {
			return isCanceled;
		}

		public void cancel() {
			isCanceled = true;
		}
	}

	public static class VirtualTimeEventTask extends VirtualTimeTask {

		private final int eventID;
		private ITimed callback;

		public VirtualTimeEventTask(ITimed callback, int eventID) {
			this.callback = callback;
			this.eventID = eventID;
		}

		public int getEventId() {
			return eventID;
		}
		
		public ITimed getCallback() {
			return callback;
		}

		public void run() {
			callback.raiseTimeEvent(eventID);
		}

	}
	
	public static class CycleTimeEventTask extends VirtualTimeTask {

		private IEventDriven statemachine;

		public CycleTimeEventTask(IEventDriven statemachine) {
			this.statemachine = statemachine;
		}

		public void run() {
		}

	}

	public VirtualTimer() {
		tasks = new PriorityQueue<VirtualTimeTask>();
	}
	
	public VirtualTimer(long cyclePeriod) {
		tasks = new PriorityQueue<VirtualTimeTask>();
		this.cyclePeriod = cyclePeriod;
	}

	public void timeLeap(long ms) {
		stopTime = currentTime.add(BigInteger.valueOf(ms));
		processTasks();
	}
	
	public void cycleLeap(long cycles){
		int elapsedCycles = 0;

		while (elapsedCycles < cycles) {

			VirtualTimeTask cycleTask = getCycleTask();
			if (cycleTask == null)
				return;

			long timeToNextCycle = cycleTask.nextExecutionTime.subtract(currentTime).longValue();
			timeLeap(timeToNextCycle);
			elapsedCycles += 1;
		}
	}

	@Override
	public void setTimer(ITimed callback, int eventID, long duration, boolean isPeriodical) {
		if (duration <= 0)
			duration = 1;
		VirtualTimeEventTask timeEventTask = new VirtualTimeEventTask(callback, eventID);
		if (isPeriodical) {
			schedulePeriodicalTask(timeEventTask, duration, duration);
		} else {
			scheduleTask(timeEventTask, duration);
		}
	}

	@Override
	public void unsetTimer(ITimed callback, int eventID) {
		VirtualTimeTask timerTask = getTask(callback, eventID);
		if (timerTask != null)
			timerTask.cancel();
	}

	public void scheduleTask(VirtualTimeTask task, long interval) {
		task.interval = interval;
		scheduleInternal(task, currentTime.add(BigInteger.valueOf(interval)), -1);
	}

	public void schedulePeriodicalTask(VirtualTimeTask task, long interval, long period) {
		scheduleInternal(task, currentTime.add(BigInteger.valueOf(interval)), period);
	}

	private void scheduleInternal(VirtualTimeTask task, BigInteger time, long period) {
		task.nextExecutionTime = time;
		task.period = period;
		task.scheduleOrder = scheduleCount;
		scheduleCount = scheduleCount.add(BigInteger.ONE);
		tasks.add(task);
	}

	protected VirtualTimeTask getTask(ITimed callback, int eventName) {
		for (VirtualTimeTask virtualTimeTask : tasks) {
			if (!(virtualTimeTask instanceof VirtualTimeEventTask))
				continue;
			if (((VirtualTimeEventTask) virtualTimeTask).getEventId() == eventName
					&& ((VirtualTimeEventTask) virtualTimeTask).getCallback() == callback)
				return virtualTimeTask;
		}
		return null;
	}
	
	protected CycleTimeEventTask getCycleTask() {
		for (VirtualTimeTask task : tasks) {
			if (task instanceof CycleTimeEventTask && !task.isCanceled()) {
				return (CycleTimeEventTask) task;
			}
		}
		return null;
	}
	
	protected void processTasks() {
		boolean processTasks = !tasks.isEmpty();
		while (processTasks) {
			VirtualTimeTask task = tasks.peek();
			if (task == null)
				break;
			if (task.isCanceled) {
				tasks.remove();
				continue;
			}
			
			if (task.nextExecutionTime.compareTo(stopTime) <= 0) {
				currentTime = task.nextExecutionTime;
				task = tasks.poll();
				if (task.period > -1) {
					task.nextExecutionTime = currentTime.add(BigInteger.valueOf(task.period));
					tasks.add(task);
				}
				task.run();
			} else {
				currentTime = stopTime;
				processTasks = false;
			}
		}
	}

	public synchronized void stop() {
		for (VirtualTimeTask timerTask : tasks) {
			timerTask.cancel();
		}
		cancel();
	}

	public void cancel() {
		synchronized (tasks) {
			tasks.clear();
		}
	}

}
