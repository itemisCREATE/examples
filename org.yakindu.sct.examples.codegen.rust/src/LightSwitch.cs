/** Generated by itemis CREATE code generator. */





//Class of the state machine 'LightSwitch'.

public class LightSwitch : IEventDrivenStatemachine,ITimed{
	
	
	
		private readonly LightSwitch.UserImpl user ;
	
	
	
		private readonly LightSwitch.LightImpl light = new LightSwitch.LightImpl();
	
		public enum State
		{
			NO_STATE,
			main_region_Off,
			main_region_On
		};
	
		private  bool isExecuting = false;
	
		/// <summary>
		/// the maximum number of orthogonal states defines the dimension of the state configuration vector.
		/// </summary>
		private const  long maxOrthogonalStates = 1L;
	
		private  LightSwitch.State[] stateConfVector = new LightSwitch.State[1L];
	
		/// <summary>
		/// Timer service for timed events.
		/// </summary>
		private static  ITimerService timerService;
	
		/// <summary>
		/// Array to hold all time events
		/// </summary>
		private static  bool[] timeEvents = new bool[0L];
	
	
	
		/// <summary>
		/// The number of states.
		/// </summary>
		public const  long NumStates = 2L;
	
		public const  long Scvi_LightSwitch_main_region_Off = 0L;
	
		public const  long Scvi_LightSwitch_main_region_On = 0L;
	
	
	
	
	
		private Queue<Delegate> incomingEventQueue = new Queue<Delegate>();
	
	
	
	
	public interface IUser  {
		public  void RaiseOn_button();
		
		
		public  void RaiseOff_button();
		
		
	}
	
	public IUser User { get { return user; }  }
	
	private class UserImpl : LightSwitch.IUser {
		
		
		private  LightSwitch parent;
		
		
		
		public UserImpl(LightSwitch parent){
			this.parent = parent;
		}
		
		internal  bool on_buttonRaised = false;
		
		
		
		public void RaiseOn_button() {
			parent.incomingEventQueue.Enqueue(() => {
				on_buttonRaised = true;
			});
			parent.RunCycle();
		}
		
		internal  bool off_buttonRaised = false;
		
		
		
		public void RaiseOff_button() {
			parent.incomingEventQueue.Enqueue(() => {
				off_buttonRaised = true;
			});
			parent.RunCycle();
		}
		
	}
	
	public interface ILight  {
		
		public long Brightness { get; set; }
		
		/// <summary>
		/// Delegate for event on of interface scope 'light'.
		/// </summary>
		public delegate void OnHandler( ILight sender,  EventArgs e);
		
		
		
		
		/// <summary>
		/// Delegate for event off of interface scope 'light'.
		/// </summary>
		public delegate void OffHandler( ILight sender,  EventArgs e);
		
		
		
		
		/// <summary>
		/// Function to subscribe for out eventon
		/// </summary>
		public  void SubscribeToOn(LightSwitch.ILight.OnHandler handlerToRegister);
		
		
		/// <summary>
		/// Function to subscribe for out eventoff
		/// </summary>
		public  void SubscribeToOff(LightSwitch.ILight.OffHandler handlerToRegister);
		
		
	}
	
	public ILight Light { get { return light; }  }
	
	private class LightImpl : LightSwitch.ILight {
		
		
		private  long brightness;
		
		
		
		public long Brightness { get { return brightness; } set { brightness = value; } }
		
		private event LightSwitch.ILight.OnHandler on;
		
		
		
		/// <summary>
		/// Function to subscribe for out eventon
		/// </summary>
		public  void SubscribeToOn(LightSwitch.ILight.OnHandler handlerToRegister) {
			on += handlerToRegister;
		} 
		
		
		public void RaiseOn() {
			on(this, new EventArgs());
		}
		
		private event LightSwitch.ILight.OffHandler off;
		
		
		
		/// <summary>
		/// Function to subscribe for out eventoff
		/// </summary>
		public  void SubscribeToOff(LightSwitch.ILight.OffHandler handlerToRegister) {
			off += handlerToRegister;
		} 
		
		
		public void RaiseOff() {
			off(this, new EventArgs());
		}
		
	}
	
	
	public bool IsExecuting { get { return isExecuting; } set { isExecuting = value; } }
	
	
	
	
	
	public  void SetTimerService(ITimerService timerServiceToRegister) {
		timerService = timerServiceToRegister;
	} 
	
	public void RaiseTimeEvent(long eventID) {
		timeEvents[eventID] = true;
		RunCycle();
	}
	
	
	
	
	public bool IsActive()
	{
		return stateConfVector[0] != State.NO_STATE;
	}
	
	public bool IsFinal()
	{
		return false;
	}
	
	public bool IsStateActive(State state)
			{
				switch (state)
				{
					case State.main_region_Off :
					{
						return (stateConfVector[Scvi_LightSwitch_main_region_Off] == State.main_region_Off);
					}
					case State.main_region_On :
					{
						return (stateConfVector[Scvi_LightSwitch_main_region_On] == State.main_region_On);
					}
					default:
					{
						/* State is not active*/
						return false;
					}
				}
			}
	
	/// <summary>
	/// Can be used by the client code to trigger a run to completion step without raising an event.
	/// </summary>
	public  void TriggerWithoutEvent() {
		RunCycle();
	} 
	
	
	protected bool GetNextEvent()
	{
		if(incomingEventQueue.Any()) {
			Delegate delegateToRun = incomingEventQueue.Dequeue();
			delegateToRun.DynamicInvoke();
			return true;
		}
		
		return false;
		
	}
	
	private  void ClearInEvents() {
		user.on_buttonRaised = false;
		user.off_buttonRaised = false;
		timeEvents[0] = false;
	} 
	
	[System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
	public LightSwitch(){
		user = new LightSwitch.UserImpl(this);
	}
	// implementations of all internal functions
	/* Entry action for state 'Off'. */
	private void LightSwitch_enact_main_region_Off()
	{
		/* Entry action for state 'Off'. */
		light.Brightness = 0L;
		light.RaiseOff();
	}
	
	/* Entry action for state 'On'. */
	private void LightSwitch_enact_main_region_On()
	{
		/* Entry action for state 'On'. */
		timerService.SetTimer(this, 0, (30L * 1000L), false);
		light.RaiseOn();
	}
	
	/* Exit action for state 'On'. */
	private void LightSwitch_exact_main_region_On()
	{
		/* Exit action for state 'On'. */
		timerService.UnsetTimer(this, 0);
	}
	
	/* 'default' enter sequence for state Off */
	private void LightSwitch_enseq_main_region_Off_default()
	{
		/* 'default' enter sequence for state Off */
		LightSwitch_enact_main_region_Off();
		stateConfVector[0] = LightSwitch.State.main_region_Off;
	}
	
	/* 'default' enter sequence for state On */
	private void LightSwitch_enseq_main_region_On_default()
	{
		/* 'default' enter sequence for state On */
		LightSwitch_enact_main_region_On();
		stateConfVector[0] = LightSwitch.State.main_region_On;
	}
	
	/* 'default' enter sequence for region main region */
	private void LightSwitch_enseq_main_region_default()
	{
		/* 'default' enter sequence for region main region */
		LightSwitch_react_main_region__entry_Default();
	}
	
	/* Default exit sequence for state Off */
	private void LightSwitch_exseq_main_region_Off()
	{
		/* Default exit sequence for state Off */
		stateConfVector[0] = LightSwitch.State.NO_STATE;
	}
	
	/* Default exit sequence for state On */
	private void LightSwitch_exseq_main_region_On()
	{
		/* Default exit sequence for state On */
		stateConfVector[0] = LightSwitch.State.NO_STATE;
		LightSwitch_exact_main_region_On();
	}
	
	/* Default exit sequence for region main region */
	private void LightSwitch_exseq_main_region()
	{
		/* Default exit sequence for region main region */
		switch (stateConfVector[0]) {
		case LightSwitch.State.main_region_Off:
			LightSwitch_exseq_main_region_Off();
			break;
		case LightSwitch.State.main_region_On:
			LightSwitch_exseq_main_region_On();
			break;
		default:
			break;
		}
	}
	
	/* Default react sequence for initial entry  */
	private void LightSwitch_react_main_region__entry_Default()
	{
		/* Default react sequence for initial entry  */
		LightSwitch_enseq_main_region_Off_default();
	}
	
	private  long React( long transitioned_before) {
		/* State machine reactions. */
		return transitioned_before;
	}
	
	private  long Main_region_Off_react( long transitioned_before) {
		/* The reactions of state Off. */
		long transitioned_after = transitioned_before;
		if (transitioned_after<0L) {
			if (user.on_buttonRaised) {
				LightSwitch_exseq_main_region_Off();
				light.Brightness = 1L;
				LightSwitch_enseq_main_region_On_default();
				React(0L);
				transitioned_after = 0L;
			}
		}
		/* If no transition was taken */
		if (transitioned_after==transitioned_before) {
			/* then execute local reactions. */
			transitioned_after = React(transitioned_before);
		}
		return transitioned_after;
	}
	
	private  long Main_region_On_react( long transitioned_before) {
		/* The reactions of state On. */
		long transitioned_after = transitioned_before;
		if (transitioned_after<0L) {
			if ((user.off_buttonRaised || timeEvents[0])) {
				LightSwitch_exseq_main_region_On();
				timeEvents[0] = false;
				LightSwitch_enseq_main_region_Off_default();
				React(0L);
				transitioned_after = 0L;
			}
		}
		/* If no transition was taken */
		if (transitioned_after==transitioned_before) {
			/* then execute local reactions. */
			if (((user.on_buttonRaised) && (light.Brightness<10L))) {
				light.Brightness += 1L;
			}
			transitioned_after = React(transitioned_before);
		}
		return transitioned_after;
	}
	
	private  void MicroStep() {
		switch (stateConfVector[0]) {
		case LightSwitch.State.main_region_Off:
			Main_region_Off_react(-1L);
			break;
		case LightSwitch.State.main_region_On:
			Main_region_On_react(-1L);
			break;
		default:
			break;
		}
	}
	
	private  void RunCycle() {
		/* Performs a 'run to completion' step. */
		if (isExecuting) {
			return;
		}
		isExecuting = true;
		GetNextEvent();
		do { 
			MicroStep();
			ClearInEvents();
		} while (GetNextEvent());
		isExecuting = false;
	}
	
	public void Enter() {
		/* Activates the state machine. */
		if (isExecuting) {
			return;
		}
		isExecuting = true;
		/* Default enter sequence for statechart LightSwitch */
		LightSwitch_enseq_main_region_default();
		isExecuting = false;
	}
	
	public void Exit() {
		/* Deactivates the state machine. */
		if (isExecuting) {
			return;
		}
		isExecuting = true;
		/* Default exit sequence for statechart LightSwitch */
		LightSwitch_exseq_main_region();
		isExecuting = false;
	}
	
}


