/** Generated by itemis CREATE code generator. */

pub mod LightSwitch {
	#[derive(PartialEq, Eq)]	
	pub enum State
	{
		NO_STATE,
		main_region_Off,
		main_region_On
	}
	
	use std::collections::VecDeque;
	
	use crate::timerservice::TimerService;
	use crate::statemachine::{Statemachine, CycleBasedStatemachine};
	use std::rc::{Rc, Weak};
	use std::cell::{RefCell};
	
	pub struct LightSwitch {
		pub brightness : usize,
		pub isExecuting : bool,
		pub // the maximum number of orthogonal states defines the dimension of the state configuration vector.
		MaxOrthogonalStates : usize,
		pub // The number of states.
		numStates : usize,
		pub scvi_LightSwitch_main_region_Off : usize,
		pub scvi_LightSwitch_main_region_On : usize,
		IncomingEventQueue : VecDeque<&'static dyn Fn(&mut Self) -> ()>,
		InternalEventQueue : VecDeque<&'static dyn Fn(&mut Self) -> ()>,
		pub timerService : TimerService,
		pub timeEvents : [bool; 2],
		pub On_button : bool,
		pub Off_button : bool,
		pub On: bool,
		pub Off: bool,
		pub instance: Weak<RefCell<dyn CycleBasedStatemachine>>,
		pub StateConfVector : [State; 1]
	}
	
	impl LightSwitch{

		pub fn RaiseOn(&mut self) {
			self.IncomingEventQueue.push_front(
				&|x : &mut LightSwitch| {
					x.On_button = true
				}
			);
			self.run_cycle();
		}

		pub fn RaiseOff(&mut self) {
			self.IncomingEventQueue.push_front(
				&|x : &mut LightSwitch| {
					x.Off_button = true
				}
			);
			self.run_cycle();
		}

		/* Entry action for state 'Off'. */
		fn LightSwitch_enact_main_region_Off(&mut self) -> ()
		{
			/* Entry action for state 'Off'. */
			self.brightness = 0;
			self.RaiseOff();
		}
		
		/* Entry action for state 'On'. */
		fn LightSwitch_enact_main_region_On(&mut self) -> ()
		{
			/* Entry action for state 'On'. */
			self.timerService.set_runcycle_timer_for((Weak::clone(&(self.instance))), 30 * 1000);
			self.RaiseOn();
		}
		
		/* Exit action for state 'On'. */
		fn LightSwitch_exact_main_region_On(&mut self) -> ()
		{
			/* Exit action for state 'On'. */
			self.timerService.unset_runcycle_time_for((Weak::clone(&(self.instance))));
		}
		
		/* 'default' enter sequence for state Off */
		fn LightSwitch_enseq_main_region_Off_default(&mut self) -> ()
		{
			/* 'default' enter sequence for state Off */
			self.LightSwitch_enact_main_region_Off();
			self.StateConfVector[0] = State::main_region_Off;
		}
		
		/* 'default' enter sequence for state On */
		fn LightSwitch_enseq_main_region_On_default(&mut self) -> ()
		{
			/* 'default' enter sequence for state On */
			self.LightSwitch_enact_main_region_On();
			self.StateConfVector[0] = State::main_region_On;
		}
		
		/* 'default' enter sequence for region main region */
		fn LightSwitch_enseq_main_region_default(&mut self) -> ()
		{
			/* 'default' enter sequence for region main region */
			self.LightSwitch_react_main_region__entry_Default();
		}
		
		/* Default exit sequence for state Off */
		fn LightSwitch_exseq_main_region_Off(&mut self) -> ()
		{
			/* Default exit sequence for state Off */
			self.StateConfVector[0] = State::NO_STATE;
		}
		
		/* Default exit sequence for state On */
		fn LightSwitch_exseq_main_region_On(&mut self) -> ()
		{
			/* Default exit sequence for state On */
			self.StateConfVector[0] = State::NO_STATE;
			self.LightSwitch_exact_main_region_On();
		}
		
		/* Default exit sequence for region main region */
		fn LightSwitch_exseq_main_region(&mut self) -> ()
		{
			/* Default exit sequence for region main region */
			match self.StateConfVector[0] {
				State::main_region_Off => {
					self.LightSwitch_exseq_main_region_Off();
				},
				State::main_region_On => {
					self.LightSwitch_exseq_main_region_On();
				}
				_ => {}
			}
		}
		
		/* Default react sequence for initial entry  */
		fn LightSwitch_react_main_region__entry_Default(&mut self) -> ()
		{
			/* Default react sequence for initial entry  */
			self.LightSwitch_enseq_main_region_Off_default();
		}
		
		/*A*/fn react(self : &Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* State machine reactions. */
					return transitioned_before;
		}
		/*A*/fn main_region_off_react(self : &mut Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* The reactions of state Off. */
					let mut transitioned_after : Option<usize> = transitioned_before;
					if transitioned_before.is_none() {
						if self.On_button {
							self.LightSwitch_exseq_main_region_Off();
							self.brightness = 1;
							self.LightSwitch_enseq_main_region_On_default();
							self.react(Some(0));
							transitioned_after = Some(0);
						}
					}
					/* If no transition was taken */
					if transitioned_after==transitioned_before {
						/* then execute local reactions. */
						transitioned_after = self.react(transitioned_before);
					}
					return transitioned_after;
		}
		/*A*/fn main_region_on_react(self : &mut Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* The reactions of state On. */
					let mut transitioned_after : Option<usize> = transitioned_before;
					if transitioned_after.is_none() {
						if (self.Off_button || self.timeEvents[0]) {
							self.LightSwitch_exseq_main_region_On();
							self.timeEvents[0] = false;
							self.LightSwitch_enseq_main_region_Off_default();
							self.react(Some(0));
							transitioned_after = Some(0);
						}
					}
					/* If no transition was taken */
					if transitioned_after==transitioned_before {
						/* then execute local reactions. */
						if ((self.On_button) && (self.brightness<(10))) {
							self.brightness += (1);
						}
						transitioned_after = self.react(transitioned_before);
					}
					return transitioned_after;
		}
		/*A*/fn clear_in_events(self : &mut Self) -> (){
					self.timeEvents[0] = false;
		}
		/*A*/fn clear_internal_events(self : &mut Self) -> (){
					self.On_button = false;
					self.Off_button = false;
					self.On = false;
					self.Off = false;
		}
		/*A*/fn micro_step(self : &mut Self) -> (){
					match self.StateConfVector[0] {
						State::main_region_Off => {
							self.main_region_off_react(None);
						},
						State::main_region_On => {
							self.main_region_on_react(None);
						}
						_ => {}
					}
		}
		/*B*/pub fn is_state_active(self : &Self, state : State) -> bool{
			match state {
				State::main_region_Off =>
				{
					return self.StateConfVector[self.scvi_LightSwitch_main_region_Off] == State::main_region_Off;
				}
				State::main_region_On =>
				{
					return self.StateConfVector[self.scvi_LightSwitch_main_region_On] == State::main_region_On;
				}
				_ =>
				{
					/* State is not active*/
					return false;
				}
			}
		}
		// Can be used by the client code to trigger a run to completion step without raising an event.
		//methodSelfDefinitionCode
		/*B*/pub fn trigger_without_event(self : &mut Self) -> () {
			self.run_cycle();
		}
		fn get_next_event(&mut self) -> bool{
			if(!self.InternalEventQueue.is_empty()) {
				let delegateToRun = self.InternalEventQueue.pop_back().expect("Error: reached unreachable code.");;
				delegateToRun(self);
				return true;
			}
			else if(!self.IncomingEventQueue.is_empty()) {
				let delegateToRun = self.IncomingEventQueue.pop_back().expect("Error: reached unreachable code.");;
				delegateToRun(self);
				return true;
			}
			false
		}
		
		pub fn New() -> Rc<RefCell<LightSwitch>>{
			let mut machine = LightSwitch {
				brightness: 0,
				isExecuting: false,
				MaxOrthogonalStates: 1,
				numStates: 2,
				scvi_LightSwitch_main_region_Off: 0,
				scvi_LightSwitch_main_region_On: 0,
				IncomingEventQueue: VecDeque::new(),
				InternalEventQueue: VecDeque::new(),
				timerService: TimerService::new(),
				timeEvents: [false, false],
				On_button: false,
				Off_button: false,
				On: false,
				Off: false,
				instance: Weak::<RefCell<Self>>::new(),
				StateConfVector: [State::NO_STATE; 1]
			};

			for state_vec_pos in 0..machine.MaxOrthogonalStates {
				machine.StateConfVector[state_vec_pos] = State::NO_STATE;
			}
			
			machine.clear_in_events();


			let current_machine = Rc::new(RefCell::new(machine));
			let cloned_machine = Rc::clone(&current_machine) as Rc<RefCell<dyn CycleBasedStatemachine>>;
			current_machine.borrow_mut().instance = Rc::downgrade(&cloned_machine);
			current_machine
		}
	}
	
	impl Statemachine for LightSwitch{
		/*A*/fn enter(self : &mut Self) -> (){
					/* Activates the state machine. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					/* Default enter sequence for statechart LightSwitch */
					self.LightSwitch_enseq_main_region_default();
					self.isExecuting = false;
		}
		/*A*/fn exit(self : &mut Self) -> (){
					/* Deactivates the state machine. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					/* Default exit sequence for statechart LightSwitch */
					self.LightSwitch_exseq_main_region();
					self.isExecuting = false;
		}
		/*B*/fn is_active(self : &Self) -> bool{
			self.StateConfVector[0] != State::NO_STATE
		}
		/*B*/fn is_final(self : &Self) -> bool{
			false
		}
	}
	
	impl CycleBasedStatemachine for LightSwitch{
		/*A*/fn run_cycle(self : &mut Self) -> (){
					/* Performs a 'run to completion' step. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					self.get_next_event();
					loop { 
						self.micro_step();
						self.clear_in_events();
						self.clear_internal_events();
						if !self.get_next_event() { break; }
					}
					
					self.isExecuting = false;
		}
	}
	
}
