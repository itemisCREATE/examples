/** Generated by itemis CREATE code generator. */

pub mod LightSwitch {
	#[derive(PartialEq, Eq)]	
	pub enum State
	{
		NO_STATE,
		main_region_Off,
		main_region_On
	}
	
	use std::collections::VecDeque;
	
	use crate::statemachine::{Statemachine, CycleBasedStatemachine};
	
	pub struct LightSwitch {
		pub brightness : usize,
		pub isExecuting : bool,
		pub // the maximum number of orthogonal states defines the dimension of the state configuration vector.
		MaxOrthogonalStates : usize,
		pub On_button : On_buttonHandlerHandler,
		pub Off_button : Off_buttonHandlerHandler,
		pub On : OnHandlerHandler,
		pub Off : OffHandlerHandler,
		pub // The number of states.
		numStates : usize,
		pub scvi_LightSwitch_main_region_Off : usize,
		pub scvi_LightSwitch_main_region_On : usize,
		pub IncomingEventQueue : VecDeque<&'a dyn Fn(&mut Self) -> ()>,
		pub InternalEventQueue : VecDeque<&'a dyn Fn(&mut Self) -> ()>,
		pub StateConfVector : [State; 1]
	}
	
	impl LightSwitch{
		/* Entry action for state 'Off'. */
		fn LightSwitch_enact_main_region_Off(&mut self) -> ()
		{
			/* Entry action for state 'Off'. */
			self.brightness = Some(0);
			RaiseOff();
		}
		
		/* Entry action for state 'On'. */
		fn LightSwitch_enact_main_region_On(&mut self) -> ()
		{
			/* Entry action for state 'On'. */
			timerService.setTimer(this, 0, (Some(30) * Some(1000)), false);
			RaiseOn();
		}
		
		/* Exit action for state 'On'. */
		fn LightSwitch_exact_main_region_On(&mut self) -> ()
		{
			/* Exit action for state 'On'. */
			timerService.unsetTimer(this, 0);
		}
		
		/* 'default' enter sequence for state Off */
		fn LightSwitch_enseq_main_region_Off_default(&mut self) -> ()
		{
			/* 'default' enter sequence for state Off */
			self.LightSwitch_enact_main_region_Off();
			self.StateConfVector[0] = State::main_region_Off;
		}
		
		/* 'default' enter sequence for state On */
		fn LightSwitch_enseq_main_region_On_default(&mut self) -> ()
		{
			/* 'default' enter sequence for state On */
			self.LightSwitch_enact_main_region_On();
			self.StateConfVector[0] = State::main_region_On;
		}
		
		/* 'default' enter sequence for region main region */
		fn LightSwitch_enseq_main_region_default(&mut self) -> ()
		{
			/* 'default' enter sequence for region main region */
			self.LightSwitch_react_main_region__entry_Default();
		}
		
		/* Default exit sequence for state Off */
		fn LightSwitch_exseq_main_region_Off(&mut self) -> ()
		{
			/* Default exit sequence for state Off */
			self.StateConfVector[0] = State::NO_STATE;
		}
		
		/* Default exit sequence for state On */
		fn LightSwitch_exseq_main_region_On(&mut self) -> ()
		{
			/* Default exit sequence for state On */
			self.StateConfVector[0] = State::NO_STATE;
			self.LightSwitch_exact_main_region_On();
		}
		
		/* Default exit sequence for region main region */
		fn LightSwitch_exseq_main_region(&mut self) -> ()
		{
			/* Default exit sequence for region main region */
			match self.StateConfVector[0] {
				State::main_region_Off => {
					self.LightSwitch_exseq_main_region_Off();
				},
				State::main_region_On => {
					self.LightSwitch_exseq_main_region_On();
				}
				_ => {}
			}
		}
		
		/* Default react sequence for initial entry  */
		fn LightSwitch_react_main_region__entry_Default(&mut self) -> ()
		{
			/* Default react sequence for initial entry  */
			self.LightSwitch_enseq_main_region_Off_default();
		}
		
		fn react(self : &mut Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* State machine reactions. */
					return transitioned_before;
		}
		fn main_region_off_react(self : &mut Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* The reactions of state Off. */
					let mut transitioned_after : Option<usize> = transitioned_before;
					if transitioned_after.is_none() {
						if self.On_button {
							self.LightSwitch_exseq_main_region_Off();
							self.brightness = Some(1);
							self.LightSwitch_enseq_main_region_On_default();
							self.react(Some(0));
							transitioned_after = Some(0);
						}
					}
					/* If no transition was taken */
					if transitioned_after==transitioned_before {
						/* then execute local reactions. */
						transitioned_after = self.react(transitioned_before);
					}
					return transitioned_after;
		}
		fn main_region_on_react(self : &mut Self, transitioned_before : Option<usize>) -> Option<usize>{
					/* The reactions of state On. */
					let mut transitioned_after : Option<usize> = transitioned_before;
					if transitioned_after.is_none() {
						if (self.Off_button || self.timeEvents[0]) {
							self.LightSwitch_exseq_main_region_On();
							self.timeEvents[0] = false;
							self.LightSwitch_enseq_main_region_Off_default();
							self.react(Some(0));
							transitioned_after = Some(0);
						}
					}
					/* If no transition was taken */
					if transitioned_after==transitioned_before {
						/* then execute local reactions. */
						if ((self.On_button) && (self.brightness<Some(10))) {
							self.brightness += Some(1);
						}
						transitioned_after = self.react(transitioned_before);
					}
					return transitioned_after;
		}
		fn clear_in_events(self : &mut Self) -> (){
					self.timeEvents[0] = false;
		}
		fn clear_internal_events(self : &mut Self) -> (){
					self.On_button = false;
					self.Off_button = false;
					self.On = false;
					self.Off = false;
		}
		fn micro_step(self : &mut Self) -> (){
					match self.StateConfVector[0] {
						State::main_region_Off => {
							self.main_region_off_react(None);
						},
						State::main_region_On => {
							self.main_region_on_react(None);
						}
						_ => {}
					}
		}
		fn is_state_active(self : &mut Self) -> bool{
			match self.StateConfVector[0] {
				State::main_region_Off =>
				{
					return self.StateConfVector[self.scvi_LightSwitch_main_region_Off] == State::main_region_Off;
				}
				State::main_region_On =>
				{
					return self.StateConfVector[self.scvi_LightSwitch_main_region_On] == State::main_region_On;
				}
				_ =>
				{
					/* State is not active*/
					return false;
				}
			}
		}
		// Can be used by the client code to trigger a run to completion step without raising an event.
		fn trigger_without_event(self : &mut Self) -> () {
			self.run_cycle();
		}
		fn get_next_event(&mut self) -> bool{
			if(!self.InternalEventQueue.is_empty()) {
				let delegateToRun = self.InternalEventQueue.pop_back().expect("Error: reached unreachable code.");;
				delegateToRun(self);
				return true;
			}
			else if(!self.IncomingEventQueue.is_empty()) {
				let delegateToRun = self.IncomingEventQueue.pop_back().expect("Error: reached unreachable code.");;
				delegateToRun(self);
				return true;
			}
			false
		}
		fn New() -> LightSwitch{
			let mut machine = LightSwitch {
				brightness: 0,
				isExecuting: false,
				MaxOrthogonalStates: 1,
				On_button: ,
				Off_button: ,
				On: ,
				Off: ,
				numStates: 2,
				scvi_LightSwitch_main_region_Off: 0,
				scvi_LightSwitch_main_region_On: 0,
				IncomingEventQueue: VecDeque::new(),
				InternalEventQueue: VecDeque::new(),
				StateConfVector: [State::NO_STATE; 1]
			};
			
			for state_vec_pos in 0..machine.MaxOrthogonalStates {
				machine.StateConfVector[state_vec_pos] = State::NO_STATE;
			}
			
			machine.clear_in_events();
			machine
		}
	}
	
	impl Statemachine for LightSwitch{
		fn enter(self : &mut Self) -> (){
					/* Activates the state machine. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					/* Default enter sequence for statechart LightSwitch */
					self.LightSwitch_enseq_main_region_default();
					self.isExecuting = false;
		}
		fn exit(self : &mut Self) -> (){
					/* Deactivates the state machine. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					/* Default exit sequence for statechart LightSwitch */
					self.LightSwitch_exseq_main_region();
					self.isExecuting = false;
		}
		fn is_active(self : &Self) -> bool{
			self.StateConfVector[0] != State::NO_STATE
		}
		fn is_final(self : &Self) -> bool{
			false
		}
	}
	
	impl CycleBasedStatemachine for LightSwitch{
		fn run_cycle(self : &mut Self) -> (){
					/* Performs a 'run to completion' step. */
					if self.isExecuting {
						return;
					}
					self.isExecuting = true;
					self.get_next_event();
					loop { 
						self.micro_step();
						self.clear_in_events();
						self.clear_internal_events();
						if !self.get_next_event() { break; }
					}
					
					self.isExecuting = false;
		}
	}
	
}
