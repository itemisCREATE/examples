/** Generated by YAKINDU Statechart Tools code generator. */

#include "sc_rxc.h"


void sc_observer_init(sc_observer *self, sc_object_ref o, sc_observer_next_fp nf)
{
	self->object = o;
	self->next = (sc_observer_next_fp) nf;
}

void sc_observer_next(sc_observer *self)
{
	if (self != sc_null && self->next != sc_null)
	{
		self->next(self->object);
	}
}


void sc_subscription_init(sc_subscription *self, sc_observer *o)
{
	self->observer = o;
	self->next = sc_null;
}


void sc_observable_init(sc_observable *self)
{
	self->subscriptions = sc_null;
}


sc_boolean sc_observable_subscribe(sc_observable *self, sc_subscription *s)
{
	sc_subscription *currentSub;
	if (s != sc_null && s->observer != sc_null && s->next == sc_null) {
		currentSub = self->subscriptions;
		s->next = (currentSub != sc_null) ? currentSub : s;
		self->subscriptions = s;
		return true;
	}
	return false;
}

sc_boolean sc_observable_unsubscribe(sc_observable *self, sc_subscription *s)
{
	sc_subscription *sub;
	
	if (s != sc_null && self->subscriptions != sc_null)
	{
		if (self->subscriptions == s) {
			self->subscriptions = (s->next != s) ? s->next : sc_null;
			s->next = sc_null;

			return true;
		}

		sub = self->subscriptions;
		while ( sub != sc_null )
		{
			if ( sub->next != sub && sub->next == s)
			{
				sub->next = (s->next != s) ? s->next : sub;
				return true;
			}

			sub = (sub->next != sub) ? sub->next : sc_null;
		}
	}
	return false;
}


void sc_observable_next(sc_observable *self)
{
	sc_subscription *sub = self->subscriptions;
	while (sub != sc_null)
	{
		if (sub->observer != sc_null)
		{
			sc_observer_next(sub->observer);
		}
		sub = (sub->next != sub) ? sub->next : sc_null;
	}
}


void sc_single_subscription_observer_init(sc_single_subscription_observer *self, sc_object_ref o, sc_observer_next_fp nf)
{
	sc_observer_init(&(self->observer), o, nf);
	sc_subscription_init(&(self->subscription), &(self->observer));
}


sc_boolean sc_single_subscription_observer_subscribe(sc_single_subscription_observer *self, sc_observable *o) {
	return sc_observable_subscribe(o, &(self->subscription));
}

sc_boolean sc_single_subscription_observer_unsubscribe(sc_single_subscription_observer *self, sc_observable *o) {
	return sc_observable_unsubscribe(o, &(self->subscription));
}


/* -----------------------------------------------------------
 * declaration of reactive extensions for all Y-SCT default types
 */

define_sc_reactive_extensions(sc_boolean)
define_sc_reactive_extensions(sc_integer)
define_sc_reactive_extensions(sc_real)

/* declaration of declare_sc_reactive_extensions(sc_string) */
void sc_observer_sc_string_init(sc_observer_sc_string *self, sc_object_ref o, sc_observer_next_sc_string_fp nf)
{
	self->object = o;
	self->next = nf;
}

void sc_observer_sc_string_next(sc_observer_sc_string *self, sc_string value)
{
	if (self != sc_null && self->next != sc_null)
	{
		self->next(self->object, value);
	}
}

void sc_observable_sc_string_init(sc_observable_sc_string *self)
{
	self->subscriptions = sc_null;
}

sc_boolean sc_observable_sc_string_subscribe(sc_observable_sc_string *self, sc_subscription_sc_string *s) {
	return sc_observable_subscribe((sc_observable*) self, (sc_subscription *) s);
}

sc_boolean sc_observable_sc_string_unsubscribe(sc_observable_sc_string *self, sc_subscription_sc_string *s) {
	return sc_observable_unsubscribe((sc_observable*) self, (sc_subscription *) s);
}

void sc_observable_sc_string_next(sc_observable_sc_string *self, sc_string value)
{
	sc_subscription_sc_string *sub = self->subscriptions;
	while (sub != sc_null)
	{
		if (sub->observer != sc_null)
		{
			sc_observer_sc_string_next(sub->observer, value);
		}
		sub = (sub->next != sub) ? sub->next : sc_null;
	}
}

void sc_single_subscription_observer_sc_string_init(sc_single_subscription_observer_sc_string *self, sc_object_ref o, sc_observer_next_sc_string_fp nf)
{
	sc_observer_sc_string_init(&(self->observer), o, nf);
	sc_subscription_sc_string_init(&(self->subscription), &(self->observer));
}

sc_boolean sc_single_subscription_observer_sc_string_subscribe(sc_single_subscription_observer_sc_string *self, sc_observable_sc_string *o) {
	return sc_observable_subscribe((sc_observable *) o, (sc_subscription *) &(self->subscription));
}

sc_boolean sc_single_subscription_observer_sc_string_unsubscribe(sc_single_subscription_observer_sc_string *self, sc_observable_sc_string *o) {
	return sc_observable_unsubscribe((sc_observable *)o, (sc_subscription *) &(self->subscription));
}

void sc_subscription_sc_string_init(sc_subscription_sc_string *self, sc_observer_sc_string *o)
{
	self->observer = o;
	self->next = sc_null;
}
