/** Generated by YAKINDU Statechart Tools code generator. */

#include "sc_yet.h"
#include "sc_types.h"
#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* The minimum message size: start char '%' or '#', a comma, a newline character and a null terminator*/
#define YET_MIN_MESSAGE_SIZE 4

static void create_message(char* buf, struct yet_message * msg);
static void create_init_message(char* buf, char* key, char* value);
static void create_update_message(char* buf, yet_timestamp timestamp, char* key, char* value);

static yet_msize get_msg_len_init(char* key, char* value);
static yet_msize get_msg_len_update(yet_timestamp timestamp, char* key, char* value);
static yet_msize get_char_count_timestamp(yet_timestamp data);

static yet_error read_message(char* text, yet_message* msg);
static yet_error read_timestamp(char* text, char** endptr, yet_message * msg);
static yet_error read_key(char* text, char** endptr, yet_message * msg);
static yet_error read_value(char* text, struct yet_message * msg);

void yet_scope_send(yet_scope* self, struct yet_message * msg)
{
	char buf[YET_SCOPE_SEND_BUF_LEN];
	yet_msize len = yet_message_len(msg);
	
	if ( len <= YET_SCOPE_SEND_BUF_LEN) {
		create_message(buf, msg);	
		sc_observable_sc_string_next(&(self->trace_messages), buf);
	}
}

static void create_init_message(char* buf, char* key, char* value)
{
	sprintf(buf, "%c%s,%s\n", YET_MESSAGE_INIT_BEGIN, key, value);
}

static void create_update_message(char* buf, yet_timestamp timestamp, char* key, char* value)
{
	if(value != NULL) {
		sprintf(buf, "%c%"PRIu64",%s,%s\n", YET_MESSAGE_UPDATE_BEGIN, timestamp, key, value);
	} else {
		sprintf(buf, "%c%"PRIu64",%s\n", YET_MESSAGE_UPDATE_BEGIN, timestamp, key);
	}
}

static void create_message(char* buf, struct yet_message * msg)
{
	if(msg->type == INIT) {
		create_init_message(buf, msg->key, msg->value);
	} else if(msg->type == UPDATE) {
		create_update_message(buf, msg->timestamp, msg->key, msg->value);
	}
}

static yet_msize get_msg_len_init(char* key, char* value)
{
	yet_msize count = YET_MIN_MESSAGE_SIZE;
	count += strlen(key);
	count += strlen(value);
	return count;
}

static yet_msize get_msg_len_update(yet_timestamp timestamp, char* key, char* value)
{
	yet_msize count = YET_MIN_MESSAGE_SIZE;
	count += get_char_count_timestamp(timestamp);
	count += strlen(key);
	if (value != NULL) {
		count += strlen(value) + 1; //For needed additional comma separator
	}
	return count;
}

yet_msize yet_message_len(yet_message* msg)
{
	if(msg->type == INIT) {
		return get_msg_len_init(msg->key, msg->value);
	} else if(msg->type == UPDATE) {
		return get_msg_len_update(msg->timestamp, msg->key, msg->value);
	}
	return 0;
}

#define D2 10ul
#define D3 100ul
#define D4 1000ul
#define D5 10000ul
#define D6 100000ul
#define D7 1000000ul
#define D8 10000000ul
#define D9 100000000ul
#define D10 1000000000ul
#define D11 10000000000ul
#define D12 100000000000ul
#define D13 1000000000000ul
#define D14 10000000000000ul
#define D15 100000000000000ul
#define D16 1000000000000000ul
#define D17 10000000000000000ul
#define D18 100000000000000000ul
#define D19 1000000000000000000ul
#define D20 10000000000000000000ul

static yet_msize get_char_count_timestamp(yet_timestamp n)
{
	if (n<D11)
		if (n<D6)
			if (n<D3)
				if (n<D2) return 1;
				else return 2;
			else
				if (n<D4) return 3;
				else
					if (n<D5) return 4;
					else return 5;
		else
			if (n<D8)
				if (n<D7) return 6;
				else return 7;
		    else
		        if (n<D9) return 8;
		        else
		        	if (n<D10) return 9;
		        	else return 10;
	else
		if (n<D16)
			if (n<D13)
				if (n<D12) return 11;
				else return 12;
			else
				if (n<D14) return 13;
				else
					if (n<D15) return 14;
					else return 15;
		else
			if (n<D18)
				if (n<D17) return 16;
				else return 17;
			else
				if (n<D19) return 18;
				else
					if (n<D20) return 19;
					else return 20;
}

static yet_error read_message(char* text, yet_message* msg)
{
	char* endptr = NULL;
	char begin;
	yet_error e;

	if(text == NULL || msg == NULL) {
		return YET_ERR_NULLPTR;
	}

	begin = *text;
	if(begin != YET_MESSAGE_INIT_BEGIN && begin != YET_MESSAGE_UPDATE_BEGIN) {
		return (YET_ERR_INVALID_MSG | YET_ERR_INVALID_BEGIN);
	}

	text++;
	if(begin == YET_MESSAGE_UPDATE_BEGIN) {
		msg->type = UPDATE;
		e = read_timestamp(text, &endptr, msg);
		if(e != 0) {
			return (YET_ERR_INVALID_MSG | e);
		}
		text = endptr + 1;
	} else {
		msg->type = INIT;
	}

	e = read_key(text, &endptr, msg);
	if(e != 0) {
		return (YET_ERR_INVALID_MSG | e);
	}

	text = endptr;
	if(begin == YET_MESSAGE_INIT_BEGIN && *text == '\0') {
		return (YET_ERR_INVALID_MSG | YET_ERR_MISSING_VALUE);
	}

	if(*text == YET_MESSAGE_SEPARATOR) {
		*text = '\0';
		e = read_value(text + 1, msg);
	} else {
		msg->value = NULL;
	}
	if(*text == '\n') {
		*text = '\0';
	}
	if(e != 0) {
		return (YET_ERR_INVALID_MSG | e);
	}
	return 0;
}

static yet_error read_timestamp(char* text, char** endptr, yet_message * msg)
{
	msg->timestamp = strtoul(text, endptr, 10);
	/*
	 * strtoul saves the address of the first character that is not a digit
	 * in endptr. If endptr == text, something went wrong / no digits were found.
	 */
	if(*endptr != text) {
		return 0;
	}

	return YET_ERR_INVALID_TIMESTAMP;
}

static yet_error read_key(char* text, char** endptr, yet_message * msg)
{
	if(text == 0 || *text == '\0') {
		return YET_ERR_INVALID_KEY;
	}
	int i = 0;
	msg->key = text;
	while(text[i] != YET_MESSAGE_SEPARATOR && text[i] != '\0' && text[i] != '\n') {
		i++;
	}
	if(i != 0) {
		*endptr = text + i;
		return 0;
	}
	return YET_ERR_INVALID_KEY;
}

static yet_error read_value(char* text, struct yet_message * msg)
{
	if(text == 0 || *text == '\0' || (*text == '\n' && *(text+1) == '\0')) {
		return YET_ERR_INVALID_VALUE;
	}
	int i = 0;
	msg->value = text;
	while(text[i] != '\0') {
		i++;
	}
	if(text[i-1] == '\n') {
		// Remove message delimiting newline character
		text[i-1] = '\0';
	}
	if(i != 0) {
		return 0;
	}
	return YET_ERR_INVALID_VALUE;
}

void yet_scope_accept_message(yet_scope *scope, char *text)
{
	struct yet_message msg;
	read_message(text, &msg);
	yet_scope_dispatch_message(scope, &msg, msg.key);
}

void yet_scope_dispatch_message(yet_scope* scope, yet_message* msg, char *fqn)
{
	char *next;
	if(scope->name != 0) {
		next = strchr(fqn, '.');
		if(next == fqn || next == 0) {
			return;
		}
		unsigned int prefix_len = next - fqn;
		if(strncmp(scope->name, fqn, prefix_len) != 0) {
			return;
		}
		next++;
	} else {
		next = fqn;
	}
	
	if(scope->num_child_scopes > 0) {
		for(int i = 0; i < scope->num_child_scopes; i++) {
			yet_scope_dispatch_message(scope->child_scopes[i], msg, next);
		}
	} else if(scope->handler != 0) {
		scope->handler(scope, msg, next);
	}
}

char* yet_scope_create_message(yet_scope* scope, char* msg, char* dst, sc_boolean meta)
{
	if(scope->parent_scope != 0) {
		dst = yet_scope_create_message(scope->parent_scope, 0, dst, meta);
	}
	if(scope->name != 0 && strlen(scope->name) > 0) {
		int name_len = strlen(scope->name);
		strncpy(dst, scope->name, name_len);
		dst += name_len;
		if(meta){
			*dst = '@';
		}else{
			*dst = '.';
		}
		dst++;
	}
	if(msg != 0) {
		strcpy(dst, msg);
		dst += strlen(msg);
		*dst = 0;
	}
	return dst;
}

void yet_scope_init(yet_scope* scope, yet_scope* parent_scope, char *name, yet_handler handler, void* instance)
{
	scope->parent_scope = parent_scope;
	scope->name = name;
	scope->handler = handler;
	scope->instance = instance;

	scope->message_receiver.object = scope;
	scope->message_receiver.next = (sc_observer_next_sc_string_fp) yet_scope_accept_message;

	sc_observable_sc_string_init(&(scope->trace_messages));
//	scope->trace_messages.observer_count = 0;
//	scope->trace_messages.subscriptions = sc_null;
}

char* yet_serialize_void(const void* from, char* to)
{
	return sc_null;
}

char* yet_serialize_sc_integer(const void* from, char* to)
{
	sc_integer intValue = *((sc_integer*)from);
	sprintf(to, "%d", intValue);
	return to;
}

char* yet_serialize_sc_real(const void* from, char* to)
{
	sc_real realValue = *((sc_real*)from);
	sprintf(to, "%f", realValue);
	return to;
}

char* yet_serialize_sc_boolean(const void* from, char* to)
{
	sc_boolean boolValue = *((sc_boolean*)from);
	if (boolValue) return "t";
	else return "f";
}

char* yet_serialize_sc_string(const void* from, char* to)
{
	return (sc_string)from;
}
